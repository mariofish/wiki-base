<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <title>Ownership and Borrowing</title>
    <link rel="stylesheet" href="/wiki-base/css/style.css" />
    <script src="//unpkg.com/@highlightjs/cdn-assets@10.6.0/highlight.min.js"></script>
    <link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@10.6.0/styles/nord.min.css">
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div class="container">
      <header id="title-block-header">
        <h1 class="title">Ownership and Borrowing</h1>
      </header>
<p><span class="menu-link"><a href="/wiki-base/index.html">index</a></span><span> &gt; </span><span class="menu-link"><a href="/wiki-base/programming/index.html">programming</a></span><span> &gt; </span><span class="menu-link"><a href="/wiki-base/programming/language/index.html">language</a></span><span> &gt; </span><span class="menu-link"><a href="/wiki-base/programming/language/rust/index.html">rust</a></span></p>
<p>Video Tutorial: <a href="https://www.youtube.com/watch?v=lQ7XF-6HYGc" class="uri">https://www.youtube.com/watch?v=lQ7XF-6HYGc</a></p>
<p>And here are some notes from the video:</p>
<h2 id="stack-v.s.-heap">Stack v.s. Heap</h2>
<h3 id="stack">Stack</h3>
<ul>
<li>Fast memory creation and retrieval</li>
<li>Memory is automatically captured by the program after variables go out of scope</li>
<li>Fixed size variables</li>
</ul>
<h3 id="heap">Heap</h3>
<ul>
<li>Flexibility</li>
<li>Memory that can grow size (Vector, HashMap, String, etc)</li>
<li>Runtime performance cost</li>
<li>Memory that can live beyond scope that created it</li>
<li>Memory is automatically recaptured when the last OWNER goes out of scope</li>
</ul>
<h2 id="ownership">Ownership</h2>
<ul>
<li>Rust
<ul>
<li>Every piece of data in memory has an owner only.</li>
<li>Allocate a Heap value to another variable remove ownership of the first variable.</li>
<li>Heap allocated memory is cleaned up automatically when the last “owner” of the memory goes out of scope.</li>
</ul></li>
<li>Other Languages
<ul>
<li>Two variables can point to the same memory.</li>
<li>Parellel and Concurrency issues such as “race condition”.</li>
</ul></li>
</ul>
<h2 id="solution">Solution</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> heap_f64<span class="op">:</span> <span class="dt">Box</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span> <span class="op">=</span> <span class="dt">Box</span><span class="pp">::</span>new(<span class="dv">2</span><span class="op">.</span>)<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    heap_procedure(heap_f64)<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;In main heap {}&quot;</span><span class="op">,</span> heap_f64)<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> heap_procedure(param<span class="op">:</span> <span class="dt">Box</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span>) <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    param <span class="op">+=</span> <span class="dv">9</span><span class="op">.</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;In heap procedure {}&quot;</span><span class="op">,</span> param)<span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>For a Heap variable, passing it as a parameter of function means transfer its ownership to the new parameter variable. And when the inner function is over, it is cleaned up automatically. Thus, it failed compiling.</p>
<p>Now, let do the borrowing:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> heap_f64<span class="op">:</span> <span class="dt">Box</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span> <span class="op">=</span> <span class="dt">Box</span><span class="pp">::</span>new(<span class="dv">2</span><span class="op">.</span>)<span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    heap_procedure(<span class="op">&amp;</span>heap_f64)<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// or just simply clone:</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">//   heap_procedure(heap_f64.clone());</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;In main heap {}&quot;</span><span class="op">,</span> heap_f64)<span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> heap_procedure(param<span class="op">:</span> <span class="op">&amp;</span><span class="dt">Box</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span>) <span class="op">{</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    param <span class="op">+=</span> <span class="dv">9</span><span class="op">.</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;In heap procedure {}&quot;</span><span class="op">,</span> param)<span class="op">;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="why-this-is-necessary">Why this is necessary?</h2>
<ul>
<li>Eliminates memory issues (null pointers, dangling pointers, data races)</li>
<li>Eliminates Garbage Collector</li>
<li>Parallel processing is a blaze!</li>
</ul>
<hr />
<p>Thanks Doug Milford for this awesome video!</p>
      <footer>
        <div>Copyright &copy; David Zhang, 2021.</div>
        <div>
          Generated by <a href="http://pandoc.org">Pandoc</a> from <a href="https://github.com/vimwiki/vimwiki">VimWiki</a>.
        </div>
      </footer>
    </div>
  </body>
</html>
